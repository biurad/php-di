<?php

declare(strict_types=1);

/*
 * This file is part of DivineNii opensource projects.
 *
 * PHP version 7.4 and above required
 *
 * @author    Divine Niiquaye Ibok <divineibok@gmail.com>
 * @copyright 2021 DivineNii (https://divinenii.com/)
 * @license   https://opensource.org/licenses/BSD-3-Clause License
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Rade\DI\Tests;

use PHPUnit\Framework\TestCase;
use Rade\DI\Container;
use Rade\DI\ContainerBuilder;
use Rade\DI\Definition;
use Rade\DI\Exceptions\ContainerResolutionException;
use Rade\DI\Exceptions\NotFoundServiceException;
use Rade\DI\Facade\Facade;
use Rade\DI\Facade\FacadeProxy;

class FacadeProxyTest extends TestCase
{
    public function testWithContainer(): void
    {
        Facade::setContainer($rade = new Container());

        $rade['raw'] = $rade->raw(123);
        $rade['service'] = new Fixtures\Service();
        $rade['service.invoke'] = new Fixtures\Invokable();
        $rade->set('service_constructor', new Fixtures\Constructor($rade));
        $rade['service.autowire_test'] = $rade->resolveClass(Fixtures\ServiceAutowire::class);
        $rade['service_callable'] = $rade->raw(static function (int $num, Fixtures\Service $service) {
            $service->value = $num;

            return $service;
        });

        $facadeProxy = new FacadeProxy($rade);
        $facadeProxy->proxy('raw', 'service', 'service.invoke', 'service_callable', 'service.autowire_test', 'serviceConstructor');

        $this->assertEquals($rade['raw'], Facade::raw());
        $this->assertSame($rade['service'], Facade::service());
        $this->assertSame($rade['service.invoke'], Facade::serviceInvoke());
        $this->assertSame($rade->call('service_callable', [5]), Facade::serviceCallable(5));
        $this->assertSame($rade['service.autowire_test'], Facade::serviceAutowireTest());
        $this->assertNull($facadeProxy->build());

        try {
            Facade::serviceConstructor();
        } catch (NotFoundServiceException $e) {
            $this->assertEquals('Identifier "serviceConstructor" is not defined. Did you mean: "service_constructor" ?', $e->getMessage());
        }

        $this->expectExceptionMessage('Subject "notExist" is not a supported proxy service.');
        $this->expectException(ContainerResolutionException::class);

        Facade::notExist();
    }

    public function testWithContainerBuilder(): void
    {
        $builder = new ContainerBuilder();

        $builder->set('raw', $builder->raw(123));
        $builder->autowire('service', Fixtures\Service::class);
        $builder->autowire('service.invoke', Fixtures\Invokable::class);
        $builder->autowire('service.autowire_test', Fixtures\ServiceAutowire::class);
        $builder->set('service_constructor', Fixtures\SomeService::class);
        $builder->set('service_private', Fixtures\Constructor::class)->should(Definition::PRIVATE);

        $facadeProxy = new FacadeProxy($builder);
        $facadeProxy->proxy('raw', 'service', 'service.invoke', 'service_constructor', 'service_private', 'service.autowire_test');
        $facadeProxy->proxy('non_existing');

        $this->assertEquals(
            <<<'FACADE_PROXY'
<?php

declare (strict_types=1);

/**
 * @internal This class has been auto-generated by the Rade DI.
 */
class Facade extends \Rade\DI\Facade\Facade
{
    public static function raw()
    {
        return self::$container->get('raw');
    }

    public static function service(): Rade\DI\Tests\Fixtures\Service
    {
        return self::$container->get('service');
    }

    public static function serviceAutowireTest(): Rade\DI\Tests\Fixtures\ServiceAutowire
    {
        return self::$container->get('service.autowire_test');
    }

    public static function serviceConstructor()
    {
        return self::$container->get('service_constructor');
    }

    public static function serviceInvoke(): Rade\DI\Tests\Fixtures\Invokable
    {
        return self::$container->get('service.invoke');
    }
}

FACADE_PROXY,
            $facadeProxy->build()
        );
    }
}
